[Skip to content](https://github.com/vultisig/vultisig-windows/blob/main/lib/dkls/vs_wasm.js#start-of-content)

You signed in with another tab or window. [Reload](https://github.com/vultisig/vultisig-windows/blob/main/lib/dkls/vs_wasm.js) to refresh your session.You signed out in another tab or window. [Reload](https://github.com/vultisig/vultisig-windows/blob/main/lib/dkls/vs_wasm.js) to refresh your session.You switched accounts on another tab or window. [Reload](https://github.com/vultisig/vultisig-windows/blob/main/lib/dkls/vs_wasm.js) to refresh your session.Dismiss alert

[vultisig](https://github.com/vultisig)/ **[vultisig-windows](https://github.com/vultisig/vultisig-windows)** Public

- [Notifications](https://github.com/login?return_to=%2Fvultisig%2Fvultisig-windows) You must be signed in to change notification settings
- [Fork\\
7](https://github.com/login?return_to=%2Fvultisig%2Fvultisig-windows)
- [Star\\
9](https://github.com/login?return_to=%2Fvultisig%2Fvultisig-windows)


## Files

main

/

# vs\_wasm.js

Copy path

Blame

Blame

## Latest commit

[![johnnyluo](https://avatars.githubusercontent.com/u/749608?v=4&size=40)](https://github.com/johnnyluo)[johnnyluo](https://github.com/vultisig/vultisig-windows/commits?author=johnnyluo)

[Update DKLS library to support migration](https://github.com/vultisig/vultisig-windows/commit/e59ca8264b4cda43abbefa2d70ee393cca32970f)

Mar 13, 2025

[e59ca82](https://github.com/vultisig/vultisig-windows/commit/e59ca8264b4cda43abbefa2d70ee393cca32970f) · Mar 13, 2025

## History

[History](https://github.com/vultisig/vultisig-windows/commits/main/lib/dkls/vs_wasm.js)

1749 lines (1631 loc) · 60.3 KB

/

# vs\_wasm.js

Top

## File metadata and controls

- Code

- Blame


1749 lines (1631 loc) · 60.3 KB

[Raw](https://github.com/vultisig/vultisig-windows/raw/refs/heads/main/lib/dkls/vs_wasm.js)

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

70

71

72

73

74

75

76

77

78

79

80

81

82

83

84

85

86

87

88

89

90

91

92

93

94

95

96

97

98

99

100

101

102

103

104

105

106

107

108

109

110

111

112

113

114

115

116

117

118

119

120

121

122

123

124

125

126

127

128

129

130

131

132

133

134

135

136

137

138

139

140

141

142

143

144

145

146

147

148

149

150

151

152

153

154

155

156

157

158

159

160

161

162

163

164

165

166

167

168

169

170

171

172

173

174

175

176

177

178

179

180

181

182

183

184

185

186

187

188

189

190

191

192

193

194

195

196

197

198

199

200

201

202

203

204

205

206

207

208

209

210

211

212

213

214

215

216

217

218

219

220

221

222

223

224

225

226

227

228

229

230

231

232

233

234

235

236

237

238

239

240

241

242

243

244

245

246

247

248

249

250

251

252

253

254

255

256

257

258

259

260

261

262

263

264

265

266

267

268

269

270

271

272

273

274

275

276

277

278

279

280

281

282

283

284

285

286

287

288

289

290

291

292

293

294

295

296

297

298

299

300

301

302

303

304

305

306

307

308

309

310

311

312

313

314

315

316

317

318

319

320

321

322

323

324

325

326

327

328

329

330

331

332

333

334

335

336

337

338

339

340

341

342

343

344

345

346

347

348

349

350

351

352

353

354

355

356

357

358

359

360

361

362

363

364

365

366

367

368

369

370

371

372

373

374

375

376

377

378

379

380

381

382

383

384

385

386

387

388

389

390

391

392

393

394

395

396

397

398

399

400

401

402

403

404

405

406

407

408

409

410

411

412

413

414

415

416

417

418

419

420

421

422

423

424

425

426

427

428

429

430

431

432

433

434

435

436

437

438

439

440

441

442

443

444

445

446

447

448

449

450

451

452

453

454

455

456

457

458

459

460

461

462

463

464

465

466

467

468

469

470

471

472

473

474

475

476

477

478

479

480

481

482

483

484

485

486

487

488

489

490

491

492

493

494

495

496

497

498

499

500

501

502

503

504

505

506

507

508

509

510

511

512

513

514

515

516

517

518

519

520

521

522

523

524

525

526

527

528

529

530

531

532

533

534

535

536

537

538

539

540

541

542

543

544

545

546

547

548

549

550

551

552

553

554

555

556

557

558

559

560

561

562

563

564

565

566

567

568

569

570

571

572

573

574

575

576

577

578

579

580

581

582

583

584

585

586

587

588

589

590

591

592

593

594

595

596

597

598

599

600

601

602

603

604

605

606

607

608

609

610

611

612

613

614

615

616

617

618

619

620

621

622

623

624

625

626

627

628

629

630

631

632

633

634

635

636

637

638

639

640

641

642

643

644

645

646

647

648

649

650

651

652

653

654

655

656

657

658

659

660

661

662

663

664

665

666

667

668

669

670

671

672

673

674

675

676

677

678

679

680

681

682

683

684

685

686

687

688

689

690

691

692

693

694

695

696

697

698

699

700

701

702

703

704

705

706

707

708

709

710

711

712

713

714

715

716

717

718

719

720

721

722

723

724

725

726

727

728

729

730

731

732

733

734

735

736

737

738

739

740

741

742

743

744

745

746

747

748

749

750

751

752

753

754

755

756

757

758

759

760

761

762

763

764

765

766

767

768

769

770

771

772

773

774

775

776

777

778

779

780

781

782

783

784

785

786

787

788

789

790

791

792

793

794

795

796

797

798

799

800

801

802

803

804

805

806

807

808

809

810

811

812

813

814

815

816

817

818

819

820

821

822

823

824

825

826

827

828

829

830

831

832

833

834

835

836

837

838

839

840

841

842

843

844

845

846

847

848

849

850

851

852

853

854

855

856

857

858

859

860

861

862

863

864

865

866

867

868

869

870

871

872

873

874

875

876

877

878

879

880

881

882

883

884

885

886

887

888

889

890

891

892

893

894

895

896

897

898

899

900

901

902

903

904

905

906

907

908

909

910

911

912

913

914

915

916

917

918

919

920

921

922

923

924

925

926

927

928

929

930

931

932

933

934

935

936

937

938

939

940

941

942

943

944

945

946

947

948

949

950

951

952

953

954

955

956

957

958

959

960

961

962

963

964

965

966

967

968

969

970

971

972

973

974

975

976

977

978

979

980

981

982

983

984

985

986

987

988

989

990

991

992

993

994

995

996

997

998

999

1000

1001

1002

1003

1004

1005

1006

1007

1008

1009

1010

1011

1012

1013

1014

1015

1016

1017

1018

1019

1020

1021

1022

1023

1024

1025

1026

1027

1028

1029

1030

1031

1032

1033

1034

1035

1036

1037

1038

1039

1040

1041

1042

1043

1044

1045

1046

1047

1048

1049

1050

1051

1052

1053

1054

1055

1056

1057

1058

1059

1060

1061

1062

1063

1064

1065

1066

1067

1068

1069

1070

1071

1072

1073

1074

1075

1076

1077

1078

1079

1080

1081

1082

1083

1084

1085

1086

1087

1088

1089

1090

1091

1092

1093

1094

1095

1096

1097

1098

1099

1100

1101

1102

1103

1104

1105

1106

1107

1108

1109

1110

1111

1112

1113

1114

1115

1116

1117

1118

1119

1120

1121

1122

1123

1124

1125

1126

1127

1128

1129

1130

1131

1132

1133

1134

1135

1136

1137

1138

1139

1140

1141

1142

1143

1144

1145

1146

1147

1148

1149

1150

1151

1152

1153

1154

1155

1156

1157

1158

1159

1160

1161

1162

1163

1164

1165

1166

1167

1168

1169

1170

1171

1172

1173

1174

1175

1176

1177

1178

1179

1180

1181

1182

1183

1184

1185

1186

1187

1188

1189

1190

1191

1192

1193

1194

1195

1196

1197

1198

1199

1200

1201

1202

1203

1204

1205

1206

1207

1208

1209

1210

1211

1212

1213

1214

1215

1216

1217

1218

1219

1220

1221

1222

1223

1224

1225

1226

1227

1228

1229

1230

1231

1232

1233

1234

1235

1236

1237

1238

1239

1240

1241

1242

1243

1244

1245

1246

1247

1248

1249

1250

1251

1252

1253

1254

1255

1256

1257

1258

1259

1260

1261

1262

1263

1264

1265

1266

1267

1268

1269

1270

1271

1272

1273

1274

1275

1276

1277

1278

1279

1280

1281

1282

1283

1284

1285

1286

1287

1288

1289

1290

1291

1292

1293

1294

1295

1296

1297

1298

1299

1300

1301

1302

1303

1304

1305

1306

1307

1308

1309

1310

1311

1312

1313

1314

1315

1316

1317

1318

1319

1320

1321

1322

1323

1324

1325

1326

1327

1328

1329

1330

1331

1332

1333

1334

1335

1336

1337

1338

1339

1340

1341

1342

1343

1344

1345

1346

1347

1348

1349

1350

1351

1352

1353

1354

1355

1356

1357

1358

1359

1360

1361

1362

1363

1364

1365

1366

1367

1368

1369

1370

1371

1372

1373

1374

1375

1376

1377

1378

1379

1380

1381

1382

1383

1384

1385

1386

1387

1388

1389

1390

1391

1392

1393

1394

1395

1396

1397

1398

1399

1400

1401

1402

1403

1404

1405

1406

1407

1408

1409

1410

1411

1412

1413

1414

1415

1416

1417

1418

1419

1420

1421

1422

1423

1424

1425

1426

1427

1428

1429

1430

1431

1432

1433

1434

1435

1436

1437

1438

1439

1440

1441

1442

1443

1444

1445

1446

1447

1448

1449

1450

1451

1452

1453

1454

1455

1456

1457

1458

1459

1460

1461

1462

1463

1464

1465

1466

1467

1468

1469

1470

1471

1472

1473

1474

1475

1476

1477

1478

1479

1480

1481

1482

1483

1484

1485

1486

1487

1488

1489

1490

1491

1492

1493

1494

1495

1496

1497

1498

1499

1500

1501

1502

1503

1504

1505

1506

1507

1508

1509

1510

1511

1512

1513

1514

1515

1516

1517

1518

1519

1520

1521

1522

1523

1524

1525

1526

1527

1528

1529

1530

1531

1532

1533

1534

1535

1536

1537

1538

1539

1540

1541

1542

1543

1544

1545

1546

1547

1548

1549

1550

1551

1552

1553

1554

1555

1556

1557

1558

1559

1560

1561

1562

1563

1564

1565

1566

1567

1568

1569

1570

1571

1572

1573

1574

1575

1576

1577

1578

1579

1580

1581

1582

1583

1584

1585

1586

1587

1588

1589

1590

1591

1592

1593

1594

1595

1596

1597

1598

1599

1600

1601

1602

1603

1604

1605

1606

1607

1608

1609

1610

1611

1612

1613

1614

1615

1616

1617

1618

1619

1620

1621

1622

1623

1624

1625

1626

1627

1628

1629

1630

1631

1632

1633

1634

1635

1636

1637

1638

1639

1640

1641

1642

1643

1644

1645

1646

1647

1648

1649

1650

1651

1652

1653

1654

1655

1656

1657

1658

1659

1660

1661

1662

1663

1664

1665

1666

1667

1668

1669

1670

1671

1672

1673

1674

1675

1676

1677

1678

1679

1680

1681

1682

1683

1684

1685

1686

1687

1688

1689

1690

1691

1692

1693

1694

1695

1696

1697

1698

1699

1700

1701

1702

1703

1704

1705

1706

1707

1708

1709

1710

1711

1712

1713

1714

1715

1716

1717

1718

1719

1720

1721

1722

1723

1724

1725

1726

1727

1728

1729

1730

1731

1732

1733

1734

1735

1736

1737

1738

1739

1740

1741

1742

1743

1744

1745

1746

1747

1748

1749

letwasm;

constheap=newArray(128).fill(undefined);

heap.push(undefined,null,true,false);

functiongetObject(idx){returnheap\[idx\];}

letheap\_next=heap.length;

functionaddHeapObject(obj){

if(heap\_next===heap.length)heap.push(heap.length+1);

constidx=heap\_next;

heap\_next=heap\[idx\];

heap\[idx\]=obj;

returnidx;

}

functionhandleError(f,args){

try{

returnf.apply(this,args);

}catch(e){

wasm.\_\_wbindgen\_exn\_store(addHeapObject(e));

}

}

constcachedTextDecoder=(typeofTextDecoder!=='undefined' ? newTextDecoder('utf-8',{ignoreBOM: true,fatal: true}) : {decode: ()=>{throwError('TextDecoder not available')}});

if(typeofTextDecoder!=='undefined'){cachedTextDecoder.decode();};

letcachedUint8ArrayMemory0=null;

functiongetUint8ArrayMemory0(){

if(cachedUint8ArrayMemory0===null\|\|cachedUint8ArrayMemory0.byteLength===0){

cachedUint8ArrayMemory0=newUint8Array(wasm.memory.buffer);

}

returncachedUint8ArrayMemory0;

}

functiongetStringFromWasm0(ptr,len){

ptr=ptr>>>0;

returncachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr,ptr+len));

}

functiondropObject(idx){

if(idx<132)return;

heap\[idx\]=heap\_next;

heap\_next=idx;

}

functiontakeObject(idx){

constret=getObject(idx);

dropObject(idx);

returnret;

}

functionisLikeNone(x){

returnx===undefined\|\|x===null;

}

letWASM\_VECTOR\_LEN=0;

constcachedTextEncoder=(typeofTextEncoder!=='undefined' ? newTextEncoder('utf-8') : {encode: ()=>{throwError('TextEncoder not available')}});

constencodeString=(typeofcachedTextEncoder.encodeInto==='function'

? function(arg,view){

returncachedTextEncoder.encodeInto(arg,view);

}

: function(arg,view){

constbuf=cachedTextEncoder.encode(arg);

view.set(buf);

return{

read: arg.length,

written: buf.length

};

});

functionpassStringToWasm0(arg,malloc,realloc){

if(realloc===undefined){

constbuf=cachedTextEncoder.encode(arg);

constptr=malloc(buf.length,1)>>>0;

getUint8ArrayMemory0().subarray(ptr,ptr+buf.length).set(buf);

WASM\_VECTOR\_LEN=buf.length;

returnptr;

}

letlen=arg.length;

letptr=malloc(len,1)>>>0;

constmem=getUint8ArrayMemory0();

letoffset=0;

for(;offset<len;offset++){

constcode=arg.charCodeAt(offset);

if(code>0x7F)break;

mem\[ptr+offset\]=code;

}

if(offset!==len){

if(offset!==0){

arg=arg.slice(offset);

}

ptr=realloc(ptr,len,len=offset+arg.length\*3,1)>>>0;

constview=getUint8ArrayMemory0().subarray(ptr+offset,ptr+len);

constret=encodeString(arg,view);

offset+=ret.written;

ptr=realloc(ptr,len,offset,1)>>>0;

}

WASM\_VECTOR\_LEN=offset;

returnptr;

}

letcachedDataViewMemory0=null;

functiongetDataViewMemory0(){

if(cachedDataViewMemory0===null\|\|cachedDataViewMemory0.buffer.detached===true\|\|(cachedDataViewMemory0.buffer.detached===undefined&&cachedDataViewMemory0.buffer!==wasm.memory.buffer)){

cachedDataViewMemory0=newDataView(wasm.memory.buffer);

}

returncachedDataViewMemory0;

}

functionpassArray8ToWasm0(arg,malloc){

constptr=malloc(arg.length\*1,1)>>>0;

getUint8ArrayMemory0().set(arg,ptr/1);

WASM\_VECTOR\_LEN=arg.length;

returnptr;

}

function\_assertClass(instance,klass){

if(!(instanceinstanceofklass)){

thrownewError(\`expected instance of ${klass.name}\`);

}

}

functionpassArrayJsValueToWasm0(array,malloc){

constptr=malloc(array.length\*4,4)>>>0;

constmem=getDataViewMemory0();

for(leti=0;i<array.length;i++){

mem.setUint32(ptr+4\*i,addHeapObject(array\[i\]),true);

}

WASM\_VECTOR\_LEN=array.length;

returnptr;

}

functiongetArrayU8FromWasm0(ptr,len){

ptr=ptr>>>0;

returngetUint8ArrayMemory0().subarray(ptr/1,ptr/1+len);

}

functiongetArrayJsValueFromWasm0(ptr,len){

ptr=ptr>>>0;

constmem=getDataViewMemory0();

constresult=\[\];

for(leti=ptr;i<ptr+4\*len;i+=4){

result.push(takeObject(mem.getUint32(i,true)));

}

returnresult;

}

letstack\_pointer=128;

functionaddBorrowedObject(obj){

if(stack\_pointer==1)thrownewError('out of js stack');

heap\[--stack\_pointer\]=obj;

returnstack\_pointer;

}

constFinalSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_finalsession\_free(ptr>>>0,1));

exportclassFinalSession{

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

FinalSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_finalsession\_free(ptr,0);

}

/\*\*

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {PreSign} pre

\*/

constructor(setup,id,pre){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen0=WASM\_VECTOR\_LEN;

\_assertClass(pre,PreSign);

varptr1=pre.\_\_destroy\_into\_raw();

wasm.finalsession\_new(retptr,addBorrowedObject(setup),ptr0,len0,ptr1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

this.\_\_wbg\_ptr=r0>>>0;

FinalSessionFinalization.register(this,this.\_\_wbg\_ptr,this);

returnthis;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

heap\[stack\_pointer++\]=undefined;

}

}

/\*\*

\\* @param {Uint8Array} session\_id

\\* @param {Uint8Array} message\_hash

\\* @param {string\[\]} ids

\\* @returns {Uint8Array}

\*/

staticsetup(session\_id,message\_hash,ids){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(session\_id,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen1=WASM\_VECTOR\_LEN;

wasm.finalsession\_setup(retptr,ptr0,len0,addHeapObject(message\_hash),ptr1,len1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returntakeObject(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract message hash form the setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupMessageHash(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.finalsession\_setupMessageHash(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract session ID from a setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupKeyId(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.finalsession\_setupKeyId(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.finalsession\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.finalsession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting signature.

\\* @returns {Uint8Array}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.finalsession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

varr3=getDataViewMemory0().getInt32(retptr+4\*3,true);

if(r3){

throwtakeObject(r2);

}

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constKeyExportSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keyexportsession\_free(ptr>>>0,1));

exportclassKeyExportSession{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(KeyExportSession.prototype);

obj.\_\_wbg\_ptr=ptr;

KeyExportSessionFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeyExportSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keyexportsession\_free(ptr,0);

}

/\*\*

\\* @param {Keyshare} share

\\* @param {string\[\]} ids

\\* @returns {KeyExportSession}

\*/

staticnew(share,ids){

\_assertClass(share,Keyshare);

constptr0=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.keyexportsession\_new(share.\_\_wbg\_ptr,ptr0,len0);

returnKeyExportSession.\_\_wrap(ret);

}

/\*\*

\\* Setup message for the session.

\\* @returns {Uint8Array}

\*/

getsetup(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyexportsession\_setup(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.keyexportsession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting secret key.

\\* @returns {Uint8Array}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyexportsession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

varr3=getDataViewMemory0().getInt32(retptr+4\*3,true);

if(r3){

throwtakeObject(r2);

}

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Return encrypted secret material from passed key share.

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {Keyshare} share

\\* @returns {Message}

\*/

staticexportShare(setup,id,share){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

\_assertClass(share,Keyshare);

wasm.keyexportsession\_exportShare(retptr,ptr0,len0,ptr1,len1,share.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnMessage.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constKeyImportInitiatorFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keyimportinitiator\_free(ptr>>>0,1));

exportclassKeyImportInitiator{

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeyImportInitiatorFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keyimportinitiator\_free(ptr,0);

}

/\*\*

\\* Create session for key import initiator and setup message for

\\* rest of parties.

\*

\\* # Arguments

\*

\\* \\* \`private\_key\` - Private key to import

\*

\\* \\* \`threshold\` - Signature threshold

\*

\\* \\* \`ids\` - List of human readable identifiers.

\\* The initiator is first in the list

\\* @param {Uint8Array} private\_key

\\* @param {number} threshold

\\* @param {string\[\]} ids

\*/

constructor(private\_key,threshold,ids){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(private\_key,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen1=WASM\_VECTOR\_LEN;

wasm.keyimportinitiator\_new(retptr,ptr0,len0,threshold,ptr1,len1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

this.\_\_wbg\_ptr=r0>>>0;

KeyImportInitiatorFinalization.register(this,this.\_\_wbg\_ptr,this);

returnthis;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Setup message for the key importers.

\\* @returns {Uint8Array}

\*/

getsetup(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyimportinitiator\_setup(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.keyimportinitiator\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.keyimportinitiator\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting key share.

\\* @returns {Keyshare}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyimportinitiator\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeyshare.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constKeyImportSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keyimportsession\_free(ptr>>>0,1));

exportclassKeyImportSession{

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeyImportSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keyimportsession\_free(ptr,0);

}

/\*\*

\\* Join key import protocol execution.

\*

\\* # Arguments

\*

\\* \\* \`setup\` - Setup message generated by \`KeyImportInitiator\`

\*

\\* \\* \`id\` - Human readable ID of the participant

\\* @param {Uint8Array} setup

\\* @param {string} id

\*/

constructor(setup,id){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

wasm.keyimportsession\_new(retptr,ptr0,len0,ptr1,len1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeyImporterSession.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.finalsession\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.finalsession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting key share.

\\* @returns {Keyshare}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyimportsession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeyshare.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constKeyImporterSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keyimportersession\_free(ptr>>>0,1));

exportclassKeyImporterSession{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(KeyImporterSession.prototype);

obj.\_\_wbg\_ptr=ptr;

KeyImporterSessionFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeyImporterSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keyimportersession\_free(ptr,0);

}

}

constKeygenSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keygensession\_free(ptr>>>0,1));

exportclassKeygenSession{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(KeygenSession.prototype);

obj.\_\_wbg\_ptr=ptr;

KeygenSessionFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeygenSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keygensession\_free(ptr,0);

}

/\*\*

\\* Allocate new key generation session

\*

\\* # Arguments

\*

\\* \\* \`setup\` - A setup message created by \`KeygenSession.setup\`

\*

\\* \\* \`id\` - A human readable party identifier

\\* @param {Uint8Array} setup

\\* @param {string} id

\*/

constructor(setup,id){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

wasm.keygensession\_new(retptr,ptr0,len0,ptr1,len1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

this.\_\_wbg\_ptr=r0>>>0;

KeygenSessionFinalization.register(this,this.\_\_wbg\_ptr,this);

returnthis;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Allocate new key refresh session

\*

\\* # Arguments

\*

\\* \\* \`setup\` - A setup message created by \`KeygenSession.setup\`

\*

\\* \\* \`id\` - A human readable party identifier

\*

\\* \\* \`old\_Share\` - Old key share

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {Keyshare} old\_share

\\* @returns {KeygenSession}

\*/

staticrefresh(setup,id,old\_share){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

\_assertClass(old\_share,Keyshare);

wasm.keygensession\_refresh(retptr,ptr0,len0,ptr1,len1,old\_share.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeygenSession.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Allocate new key migration session

\*

\\* # Arguments

\*

\\* \\* \`setup\` - A setup message created by \`KeygenSession.setup\`

\*

\\* \\* \`id\` - A human readable party identifier

\*

\\* \\* \`s\_i\_0\` - The additive share of the party such that Σ(s\_i\_0) = private key , 0<=i<=n

\*

\\* \\* \`publickey\` - The generic common public key

\*

\\* \\* \`rootChainCode\` - The root chain code

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {Uint8Array} s\_i\_0

\\* @param {Uint8Array} public\_key

\\* @param {Uint8Array} root\_chain\_code

\\* @returns {KeygenSession}

\*/

staticmigrate(setup,id,s\_i\_0,public\_key,root\_chain\_code){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

constptr2=passArray8ToWasm0(s\_i\_0,wasm.\_\_wbindgen\_malloc);

constlen2=WASM\_VECTOR\_LEN;

constptr3=passArray8ToWasm0(public\_key,wasm.\_\_wbindgen\_malloc);

constlen3=WASM\_VECTOR\_LEN;

constptr4=passArray8ToWasm0(root\_chain\_code,wasm.\_\_wbindgen\_malloc);

constlen4=WASM\_VECTOR\_LEN;

wasm.keygensession\_migrate(retptr,ptr0,len0,ptr1,len1,ptr2,len2,ptr3,len3,ptr4,len4);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeygenSession.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Create a new DKG setup message.

\*

\\* # Arguments

\*

\\* \\* \`key\_id\` - Optional array of 32 bytes to identify an existing

\\* key share for key refresh.

\*

\\* \\* \`threshold\` - Threshold parameter.

\*

\\* \\* \`ids\` - Array of party identities.

\\* @param {Uint8Array \| null \| undefined} key\_id

\\* @param {number} threshold

\\* @param {string\[\]} ids

\\* @returns {Uint8Array}

\*/

staticsetup(key\_id,threshold,ids){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

varptr0=isLikeNone(key\_id) ? 0 : passArray8ToWasm0(key\_id,wasm.\_\_wbindgen\_malloc);

varlen0=WASM\_VECTOR\_LEN;

constptr1=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen1=WASM\_VECTOR\_LEN;

wasm.keygensession\_setup(retptr,ptr0,len0,threshold,ptr1,len1);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv3=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv3;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract key ID from a setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupKeyId(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.keygensession\_setupKeyId(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.keygensession\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.keygensession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting key share.

\\* @returns {Keyshare}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keygensession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeyshare.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constKeyshareFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_keyshare\_free(ptr>>>0,1));

exportclassKeyshare{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(Keyshare.prototype);

obj.\_\_wbg\_ptr=ptr;

KeyshareFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

KeyshareFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_keyshare\_free(ptr,0);

}

/\*\*

\\* Return public key as compressed encoding of the public key.

\\* @returns {Uint8Array}

\*/

publicKey(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyshare\_publicKey(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Return key Id.

\\* @returns {Uint8Array}

\*/

keyId(){

constret=wasm.keyshare\_keyId(this.\_\_wbg\_ptr);

returntakeObject(ret);

}

/\*\*

\\* Serialize the keyshare into array of bytes.

\\* @returns {Uint8Array}

\*/

toBytes(){

constret=wasm.keyshare\_toBytes(this.\_\_wbg\_ptr);

returntakeObject(ret);

}

/\*\*

\\* Deserialize keyshare from the array of bytes.

\\* @param {Uint8Array} bytes

\\* @returns {Keyshare}

\*/

staticfromBytes(bytes){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.keyshare\_fromBytes(retptr,addHeapObject(bytes));

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnKeyshare.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Returns the common chaincode that has been computed at keygen

\\* @returns {Uint8Array}

\*/

rootChainCode(){

constret=wasm.keyshare\_rootChainCode(this.\_\_wbg\_ptr);

returntakeObject(ret);

}

}

constMessageFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_message\_free(ptr>>>0,1));

exportclassMessage{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(Message.prototype);

obj.\_\_wbg\_ptr=ptr;

MessageFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

MessageFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_message\_free(ptr,0);

}

/\*\*

\\* Body of the message

\\* @returns {Uint8Array}

\*/

getbody(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.message\_body(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* A list of message receviers.

\\* @returns {string\[\]}

\*/

getreceivers(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.message\_receivers(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv1=getArrayJsValueFromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*4,4);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constPreSignFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_presign\_free(ptr>>>0,1));

exportclassPreSign{

static\_\_wrap(ptr){

ptr=ptr>>>0;

constobj=Object.create(PreSign.prototype);

obj.\_\_wbg\_ptr=ptr;

PreSignFinalization.register(obj,obj.\_\_wbg\_ptr,obj);

returnobj;

}

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

PreSignFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_presign\_free(ptr,0);

}

/\*\*

\\* Serialize the PreSign into array of bytes.

\\* @returns {Uint8Array}

\*/

toBytes(){

constptr=this.\_\_destroy\_into\_raw();

constret=wasm.presign\_toBytes(ptr);

returntakeObject(ret);

}

/\*\*

\\* Deserialize PreSign from the array of bytes.

\\* @param {Uint8Array} bytes

\\* @returns {PreSign}

\*/

staticfromBytes(bytes){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(bytes,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.presign\_fromBytes(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnPreSign.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constQcSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_qcsession\_free(ptr>>>0,1));

exportclassQcSession{

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

QcSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_qcsession\_free(ptr,0);

}

/\*\*

\\* Allocate new QC session

\*

\\* # Arguments

\*

\\* \\* \`setup\` - A setup message created by \`QcSession.setup\`

\*

\\* \\* \`id\` - A human readable party identifier

\*

\\* \\* \`keyshare\` - Optional keyshare, passed to "old" parties

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {Keyshare \| null} \[keyshare\]

\*/

constructor(setup,id,keyshare){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

letptr2=0;

if(!isLikeNone(keyshare)){

\_assertClass(keyshare,Keyshare);

ptr2=keyshare.\_\_destroy\_into\_raw();

}

wasm.qcsession\_new(retptr,ptr0,len0,ptr1,len1,ptr2);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

this.\_\_wbg\_ptr=r0>>>0;

QcSessionFinalization.register(this,this.\_\_wbg\_ptr,this);

returnthis;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Create a new QC setup message.

\*

\\* # Arguments

\*

\\* \\* \`keyshare\` - keyshare.

\*

\\* \\* \`ids\` - Array of party identities.

\*

\\* \\* \`olds\` - Array of indices of old parties.

\*

\\* \\* \`threshold\` - New threshold parameter.

\*

\\* \\* \`news\` - Array of indices of new parties.

\\* @param {Keyshare} keyshare

\\* @param {string\[\]} ids

\\* @param {Uint8Array} olds

\\* @param {number} threshold

\\* @param {Uint8Array} news

\\* @returns {Uint8Array}

\*/

staticsetup(keyshare,ids,olds,threshold,news){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

\_assertClass(keyshare,Keyshare);

constptr0=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passArray8ToWasm0(olds,wasm.\_\_wbindgen\_malloc);

constlen1=WASM\_VECTOR\_LEN;

constptr2=passArray8ToWasm0(news,wasm.\_\_wbindgen\_malloc);

constlen2=WASM\_VECTOR\_LEN;

wasm.qcsession\_setup(retptr,keyshare.\_\_wbg\_ptr,ptr0,len0,ptr1,len1,threshold,ptr2,len2);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varv4=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv4;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract key ID from a setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupKeyId(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.qcsession\_setupKeyId(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.qcsession\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.qcsession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting keyshare for new

\\* parties or \`undefined\` for old parties.

\\* @returns {Keyshare \| undefined}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.qcsession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returnr0===0 ? undefined : Keyshare.\_\_wrap(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

constSignSessionFinalization=(typeofFinalizationRegistry==='undefined')

? {register: ()=>{},unregister: ()=>{}}

: newFinalizationRegistry(ptr=>wasm.\_\_wbg\_signsession\_free(ptr>>>0,1));

exportclassSignSession{

\_\_destroy\_into\_raw(){

constptr=this.\_\_wbg\_ptr;

this.\_\_wbg\_ptr=0;

SignSessionFinalization.unregister(this);

returnptr;

}

free(){

constptr=this.\_\_destroy\_into\_raw();

wasm.\_\_wbg\_signsession\_free(ptr,0);

}

/\*\*

\\* Allocate a signature generation session

\*

\\* # Arguments

\*

\\* \\* \`setup\` - Setup message created by \`SignSession.setup()\`

\*

\\* \\* \`id\` - Party identifier

\*

\\* \\* \`share\` - Key share object

\\* @param {Uint8Array} setup

\\* @param {string} id

\\* @param {Keyshare} share

\*/

constructor(setup,id,share){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passStringToWasm0(id,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen0=WASM\_VECTOR\_LEN;

\_assertClass(share,Keyshare);

wasm.signsession\_new(retptr,addBorrowedObject(setup),ptr0,len0,share.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

this.\_\_wbg\_ptr=r0>>>0;

SignSessionFinalization.register(this,this.\_\_wbg\_ptr,this);

returnthis;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

heap\[stack\_pointer++\]=undefined;

}

}

/\*\*

\\* Generate a setup message for signature generation session.

\*

\\* # Arguments

\*

\\* \\* \`key\_id\` - 32 bytes array identifing a distributed key

\*

\\* \\* \`chain\_path\` - Key derivation path

\*

\\* \\* \`message\_hash\` - optional 32 bytes of hash of a message to sign.

\\* If not passed then generate setup message for

\\* a pre-sign session.

\*

\\* \\* \`ids\` - Array of party identifiers

\\* @param {Uint8Array} key\_id

\\* @param {string} chain\_path

\\* @param {Uint8Array \| null \| undefined} message\_hash

\\* @param {string\[\]} ids

\\* @returns {Uint8Array}

\*/

staticsetup(key\_id,chain\_path,message\_hash,ids){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(key\_id,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constptr1=passStringToWasm0(chain\_path,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

constlen1=WASM\_VECTOR\_LEN;

constptr2=passArrayJsValueToWasm0(ids,wasm.\_\_wbindgen\_malloc);

constlen2=WASM\_VECTOR\_LEN;

wasm.signsession\_setup(retptr,ptr0,len0,ptr1,len1,isLikeNone(message\_hash) ? 0 : addHeapObject(message\_hash),ptr2,len2);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

if(r2){

throwtakeObject(r1);

}

returntakeObject(r0);

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract message hash form the setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupMessageHash(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.signsession\_setupMessageHash(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Extract key ID from a setup message.

\\* @param {Uint8Array} setup\_msg

\\* @returns {Uint8Array \| undefined}

\*/

staticsetupKeyId(setup\_msg){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

constptr0=passArray8ToWasm0(setup\_msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

wasm.signsession\_setupKeyId(retptr,ptr0,len0);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

letv2;

if(r0!==0){

v2=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

}

returnv2;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

/\*\*

\\* Get next output message. If no pending output message available,

\\* \`undefined\` will be returned.

\*

\\* Messages are authenticated and encrypted if required.

\\* @returns {Message \| undefined}

\*/

outputMessage(){

constret=wasm.signsession\_outputMessage(this.\_\_wbg\_ptr);

returnret===0 ? undefined : Message.\_\_wrap(ret);

}

/\*\*

\\* Handle an input message. If processing of the input message moves the

\\* session into some final state then it will return \`true\`.

\*

\\* Passing messages out of order is OK.

\*

\\* Invalid messages will be silently ignored.

\\* @param {Uint8Array} msg

\\* @returns {boolean}

\*/

inputMessage(msg){

constptr0=passArray8ToWasm0(msg,wasm.\_\_wbindgen\_malloc);

constlen0=WASM\_VECTOR\_LEN;

constret=wasm.signsession\_inputMessage(this.\_\_wbg\_ptr,ptr0,len0);

returnret!==0;

}

/\*\*

\\* Finish the session and return resulting signature or pre-sign object.

\\* @returns {Uint8Array}

\*/

finish(){

try{

constretptr=wasm.\_\_wbindgen\_add\_to\_stack\_pointer(-16);

wasm.signsession\_finish(retptr,this.\_\_wbg\_ptr);

varr0=getDataViewMemory0().getInt32(retptr+4\*0,true);

varr1=getDataViewMemory0().getInt32(retptr+4\*1,true);

varr2=getDataViewMemory0().getInt32(retptr+4\*2,true);

varr3=getDataViewMemory0().getInt32(retptr+4\*3,true);

if(r3){

throwtakeObject(r2);

}

varv1=getArrayU8FromWasm0(r0,r1).slice();

wasm.\_\_wbindgen\_free(r0,r1\*1,1);

returnv1;

}finally{

wasm.\_\_wbindgen\_add\_to\_stack\_pointer(16);

}

}

}

asyncfunction\_\_wbg\_load(module,imports){

if(typeofResponse==='function'&&moduleinstanceofResponse){

if(typeofWebAssembly.instantiateStreaming==='function'){

try{

returnawaitWebAssembly.instantiateStreaming(module,imports);

}catch(e){

if(module.headers.get('Content-Type')!='application/wasm'){

console.warn("\`WebAssembly.instantiateStreaming\` failed because your server does not serve Wasm with \`application/wasm\` MIME type. Falling back to \`WebAssembly.instantiate\` which is slower. Original error:\\n",e);

}else{

throwe;

}

}

}

constbytes=awaitmodule.arrayBuffer();

returnawaitWebAssembly.instantiate(bytes,imports);

}else{

constinstance=awaitWebAssembly.instantiate(module,imports);

if(instanceinstanceofWebAssembly.Instance){

return{ instance, module };

}else{

returninstance;

}

}

}

function\_\_wbg\_get\_imports(){

constimports={};

imports.wbg={};

imports.wbg.\_\_wbg\_buffer\_609cc3eee51ed158=function(arg0){

constret=getObject(arg0).buffer;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_call\_672a4d21634d4a24=function(){returnhandleError(function(arg0,arg1){

constret=getObject(arg0).call(getObject(arg1));

returnaddHeapObject(ret);

},arguments)};

imports.wbg.\_\_wbg\_call\_7cccdd69e0791ae2=function(){returnhandleError(function(arg0,arg1,arg2){

constret=getObject(arg0).call(getObject(arg1),getObject(arg2));

returnaddHeapObject(ret);

},arguments)};

imports.wbg.\_\_wbg\_crypto\_ed58b8e10a292839=function(arg0){

constret=getObject(arg0).crypto;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_getRandomValues\_bcb4912f16000dc4=function(){returnhandleError(function(arg0,arg1){

getObject(arg0).getRandomValues(getObject(arg1));

},arguments)};

imports.wbg.\_\_wbg\_length\_a446193dc22c12f8=function(arg0){

constret=getObject(arg0).length;

returnret;

};

imports.wbg.\_\_wbg\_msCrypto\_0a36e2ec3a343d26=function(arg0){

constret=getObject(arg0).msCrypto;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_new\_a12002a7f91c75be=function(arg0){

constret=newUint8Array(getObject(arg0));

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_newnoargs\_105ed471475aaf50=function(arg0,arg1){

constret=newFunction(getStringFromWasm0(arg0,arg1));

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_newwithbyteoffsetandlength\_d97e637ebe145a9a=function(arg0,arg1,arg2){

constret=newUint8Array(getObject(arg0),arg1>>>0,arg2>>>0);

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_newwithlength\_a381634e90c276d4=function(arg0){

constret=newUint8Array(arg0>>>0);

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_node\_02999533c4ea02e3=function(arg0){

constret=getObject(arg0).node;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_process\_5c1d670bc53614b8=function(arg0){

constret=getObject(arg0).process;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_randomFillSync\_ab2cfe79ebbf2740=function(){returnhandleError(function(arg0,arg1){

getObject(arg0).randomFillSync(takeObject(arg1));

},arguments)};

imports.wbg.\_\_wbg\_require\_79b1e9274cde3c87=function(){returnhandleError(function(){

constret=module.require;

returnaddHeapObject(ret);

},arguments)};

imports.wbg.\_\_wbg\_set\_65595bdd868b3009=function(arg0,arg1,arg2){

getObject(arg0).set(getObject(arg1),arg2>>>0);

};

imports.wbg.\_\_wbg\_static\_accessor\_GLOBAL\_88a902d13a557d07=function(){

constret=typeofglobal==='undefined' ? null : global;

returnisLikeNone(ret) ? 0 : addHeapObject(ret);

};

imports.wbg.\_\_wbg\_static\_accessor\_GLOBAL\_THIS\_56578be7e9f832b0=function(){

constret=typeofglobalThis==='undefined' ? null : globalThis;

returnisLikeNone(ret) ? 0 : addHeapObject(ret);

};

imports.wbg.\_\_wbg\_static\_accessor\_SELF\_37c5d418e4bf5819=function(){

constret=typeofself==='undefined' ? null : self;

returnisLikeNone(ret) ? 0 : addHeapObject(ret);

};

imports.wbg.\_\_wbg\_static\_accessor\_WINDOW\_5de37043a91a9c40=function(){

constret=typeofwindow==='undefined' ? null : window;

returnisLikeNone(ret) ? 0 : addHeapObject(ret);

};

imports.wbg.\_\_wbg\_subarray\_aa9065fa9dc5df96=function(arg0,arg1,arg2){

constret=getObject(arg0).subarray(arg1>>>0,arg2>>>0);

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbg\_versions\_c71aa1626a93e0a1=function(arg0){

constret=getObject(arg0).versions;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbindgen\_error\_new=function(arg0,arg1){

constret=newError(getStringFromWasm0(arg0,arg1));

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbindgen\_is\_function=function(arg0){

constret=typeof(getObject(arg0))==='function';

returnret;

};

imports.wbg.\_\_wbindgen\_is\_object=function(arg0){

constval=getObject(arg0);

constret=typeof(val)==='object'&&val!==null;

returnret;

};

imports.wbg.\_\_wbindgen\_is\_string=function(arg0){

constret=typeof(getObject(arg0))==='string';

returnret;

};

imports.wbg.\_\_wbindgen\_is\_undefined=function(arg0){

constret=getObject(arg0)===undefined;

returnret;

};

imports.wbg.\_\_wbindgen\_memory=function(){

constret=wasm.memory;

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbindgen\_object\_clone\_ref=function(arg0){

constret=getObject(arg0);

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbindgen\_object\_drop\_ref=function(arg0){

takeObject(arg0);

};

imports.wbg.\_\_wbindgen\_string\_get=function(arg0,arg1){

constobj=getObject(arg1);

constret=typeof(obj)==='string' ? obj : undefined;

varptr1=isLikeNone(ret) ? 0 : passStringToWasm0(ret,wasm.\_\_wbindgen\_malloc,wasm.\_\_wbindgen\_realloc);

varlen1=WASM\_VECTOR\_LEN;

getDataViewMemory0().setInt32(arg0+4\*1,len1,true);

getDataViewMemory0().setInt32(arg0+4\*0,ptr1,true);

};

imports.wbg.\_\_wbindgen\_string\_new=function(arg0,arg1){

constret=getStringFromWasm0(arg0,arg1);

returnaddHeapObject(ret);

};

imports.wbg.\_\_wbindgen\_throw=function(arg0,arg1){

thrownewError(getStringFromWasm0(arg0,arg1));

};

returnimports;

}

function\_\_wbg\_init\_memory(imports,memory){

}

function\_\_wbg\_finalize\_init(instance,module){

wasm=instance.exports;

\_\_wbg\_init.\_\_wbindgen\_wasm\_module=module;

cachedDataViewMemory0=null;

cachedUint8ArrayMemory0=null;

returnwasm;

}

functioninitSync(module){

if(wasm!==undefined)returnwasm;

if(typeofmodule!=='undefined'){

if(Object.getPrototypeOf(module)===Object.prototype){

({module}=module)

}else{

console.warn('using deprecated parameters for \`initSync()\`; pass a single object instead')

}

}

constimports=\_\_wbg\_get\_imports();

\_\_wbg\_init\_memory(imports);

if(!(moduleinstanceofWebAssembly.Module)){

module=newWebAssembly.Module(module);

}

constinstance=newWebAssembly.Instance(module,imports);

return\_\_wbg\_finalize\_init(instance,module);

}

asyncfunction\_\_wbg\_init(module\_or\_path){

if(wasm!==undefined)returnwasm;

if(typeofmodule\_or\_path!=='undefined'){

if(Object.getPrototypeOf(module\_or\_path)===Object.prototype){

({module\_or\_path}=module\_or\_path)

}else{

console.warn('using deprecated parameters for the initialization function; pass a single object instead')

}

}

if(typeofmodule\_or\_path==='undefined'){

module\_or\_path=newURL('vs\_wasm\_bg.wasm',import.meta.url);

}

constimports=\_\_wbg\_get\_imports();

if(typeofmodule\_or\_path==='string'\|\|(typeofRequest==='function'&&module\_or\_pathinstanceofRequest)\|\|(typeofURL==='function'&&module\_or\_pathinstanceofURL)){

module\_or\_path=fetch(module\_or\_path);

}

\_\_wbg\_init\_memory(imports);

const{ instance, module }=await\_\_wbg\_load(awaitmodule\_or\_path,imports);

return\_\_wbg\_finalize\_init(instance,module);

}

export{initSync};

exportdefault\_\_wbg\_init;

You can’t perform that action at this time.


While the code is focused, press Alt+F1 for a menu of operations.